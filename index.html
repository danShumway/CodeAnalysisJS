<!--Just sample code from http://ace.c9.io/#nav=embedding-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>ACE in Action</title>
<style type="text/css" media="screen">
    #editor { 
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
</style>
</head>
<body>

<div id="editor">

function foo(items) {
    var b;
    for(var i = 0; i &lt; 10; i++) {
        b++;
    }
    var x = "All this is syntax highlighted";
    //return x;
}


</div>
    
<script src="scripts/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="scripts/acorn/acorn.js" type="text/javascript" charset="utf-8"></script>

<script>

    var annalyze = false;

    function _init() {


        var scope = {};

        //-------------------SETUP AND VARIABLES-------------------------------------------------

        //Included code for setting up the editor.
        //Ace editor is cool.
        var editor = ace.edit("editor");
        editor.setTheme("ace/theme/monokai");
        editor.getSession().setMode("ace/mode/javascript");

        //
        scope.session = editor.getSession(); //Maybe unnecessary?
        scope.pause = false;
        
        var whitelist = [{
                type:"BlockStatement",
                whitelist: [{type:"ForStatement"}, {type:"ReturnStatement"}],
                blacklist: [{type:"IfStatement"}]
            }];
        var blacklist = [];
        var structure = [];
        var whitelist_found = [];
        var blacklist_found = [];


        //-----------------GET USER INPUT---------------------------------------------------------

        var changeTimer = 800;
        //Set up hooks for evaluation.
        editor.getSession().getDocument().on('change', function(e) {
            changeTimer = 800; //If you type something, and don't type something else for 800 miliseconds, then we parse the code.  But we really don't want to parse while you're typing.  That's annoying.
        });



        var time = new Date().getTime();
        //Handles periodically checking for changes and sending out a command to parse the program.
        function getChanges(){
            //How long has elapsed?
            var dx = new Date().getTime() - time;
            time = time + dx;

            if(changeTimer > 0) { changeTimer -= dx; }
            //I allow a refresh every 15 seconds even if you are just sitting there 
            //who knows, maybe we missed something once.  Still wouldn't be ideal, but...
            if(changeTimer <= 0) { parseInformation(); changeTimer = /*1*/85000; }
            window.requestAnimationFrame(getChanges);
        }; getChanges(); //Run immediately


        //-------------------------------CODE REVIEW----------------------------------------------

        //Returns {}
        function parseInformation() {
            //First check to see if there are any errors or messages.
            var annotations = editor.getSession().getAnnotations();
            //Don't compile if there are errors, there wouldn't be any point.
            for(var i = 0; i < annotations.length; i++){
                if(annotations[i].type == "error") { return; }
            }
            
            var tree = acorn.parse(scope.session.getValue());

            whitelist_found = [];
            blacklist_found = []; //Reset what we've found.
            codeReview(whitelist, tree, whitelist_found, blacklist_found);
        };


        //Loops through whitelist and blacklist and populates two given arrays with the found patterns.
        //ID is an optional parameter - if you're calling this yourself, don't set it.
        function codeReview(list, tree, whitelistResults, blacklistResults, id) {
            for(var required in list) {
                (function(required, id) {
                    bfs(tree, list[required], function(found){
                        if(found.length === 0) {
                            //We didn't find it, but we still might.
                            //Make sure it's not in the whitelist.

                        } else {
                            if(whitelistResults.indexOf(id || required) === -1) { 
                                whitelistResults.push(id || required);
                            }

                            list[required].whitelist_found = [];
                            list[required].blacklist_found = [];
                            for(var node in found) {
                                //Look down at the children.
                                codeReview(list[required].whitelist || [], found[node], list[required].whitelist_found, list[required].blacklist_found);//, id || required);
                                codeReview(list[required].blacklist || [], found[node], list[required].blacklist_found, list[required].blacklist_found);
                            }
                        }
                    });
                })(required, id);
            }
        }

        //Simple Breadth-First-Search, adapted to take advantage of requestAnimationFrame.
        //Returns an array of all matching nodes
        function bfs(code_tree, object, callback) {
            var toCheck = []; toCheck.push(code_tree);
            var found = [];
            //while(toCheck.length > 0){

            //Leveraging requestAnimationFrame should prevent slowdown on long searches.
            (function runCheck() {
                if (objEquals(toCheck[0], object)) { found.push(toCheck[0]); } //Did we find a match.
                //Check subtrees.
                if(toCheck[0].body instanceof Array) {
                    for(var obj in toCheck[0].body) {
                        toCheck.push(toCheck[0].body[obj]);
                    }
                } else if (toCheck[0].body !== undefined){
                    toCheck.push(toCheck[0].body);
                }
                //And remove.
                toCheck.shift(); //O(n) - not the most efficient in the world, but it's probably fine.

                //Re-run.
                if(toCheck.length > 0) { 
                    window.requestAnimationFrame(runCheck); 
                } else { callback(found); }
            })();    
        };

        //Checks to see if an object fulfills all the requirements of a test object.
        //Does not count body as a requirement.
        function objEquals(obj, testObj) {
            for(var p in testObj){
                if(p !== "whitelist" && p !== "blacklist" && p !== "whitelist_found" && p !== "blacklist_found") {
                    if(obj[p] !== testObj[p]) {
                        return false;
                    }
                }
            }
            return true;
        };

        //----------------GETTING RESULTS OF CODE REVIEW----------------------------

        //Returns a {found:boolean, messages:[array of strings]
        function parseReview(whitelist, blacklist, whitelist_found, blacklist_found, error) {
            var toReturn = false; var i = 0;

            if(!whitelist){ whitelist = []; } if(!blacklist){ blacklist = []; }
            if(!whitelist_found){ whitelist_found = []; } if(!blacklist_found){ blacklist_found = []; }

            whiteRequirement = true;
            blackRequirement = true;

            //Check blacklist.
            for(i = 0; i < blacklist.length; i++) {
                //Any blacklist items found?
                if(blacklist_found.indexOf(i) !== -1) {
                    //Make sure they're really found.
                    blackRequiremnt = !(parseReview(blacklist[i].whitelist, blacklist[i].blacklist, blacklist[i].whitelist_found, blacklist[i].blacklist_found));
                }
            }

            //Check whitelist.
            for(i = 0; i < whitelist.length; i++){
                if(whitelist_found.indexOf("" + i) !== -1) {
                    //Any sure it's really found.
                    whiteRequirement = parseReview(whitelist[i].whitelist, whitelist[i].blacklist, whitelist[i].whitelist_found, whitelist[i].blacklist_found);
                } else {
                    //console.log("didn't find: "); console.log(whitelist[i]);
                    whiteRequirement = false;
                }
            }

            return (whiteRequirement && blackRequirement);
        }

        var x = 30;
        function gotRequirements(){
            x--;
            if(x < 0) {
                x = 30;
                console.log(parseReview(whitelist, blacklist, whitelist_found, blacklist_found, undefined));
            }
            window.requestAnimationFrame(gotRequirements);
        } gotRequirements();

        //---------------------RETURN--------------------------------------------------

        return scope;
    }

    window.editor = _init();

</script>
</body>
</html>