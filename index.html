<!--Just sample code from http://ace.c9.io/#nav=embedding-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>ACE in Action</title>
<style type="text/css" media="screen">
    #editor { 
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
</style>
</head>
<body>

<div id="editor">

function foo(items) {
    var b;
    for(var i = 0; i &lt; 10; i++) {
        b++;
    }
    var x = "All this is syntax highlighted";
    return x;
}


</div>
    
<script src="scripts/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="scripts/acorn/acorn.js" type="text/javascript" charset="utf-8"></script>

<script>

    var annalyze = false;

    function _init() {


        var scope = {};

        //-------------------SETUP AND VARIABLES-------------------------------------------------

        //Included code for setting up the editor.
        //Ace editor is cool.
        var editor = ace.edit("editor");
        editor.setTheme("ace/theme/monokai");
        editor.getSession().setMode("ace/mode/javascript");

        //
        scope.session = editor.getSession(); //Maybe unnecessary?
        scope.pause = false;
        
        var whiteList = [];
        var blackList = [];
        var structure = [];



        var changeTimer = 800;
        //Set up hooks for evaluation.
        editor.getSession().getDocument().on('change', function(e) {
            //Otherwise, record that there's new information, and we need to evaluate it soon.
            //Basically, we'll wait for the user to stop typing.
            changeTimer = 800; //If you type something, and don't type something else for 800 miliseconds, then we parse the code.  But we really don't want to parse while you're typing.
        });



        var time = new Date().getTime();
        //Handles periodically checking for changes and sending out a command to parse the program.
        function getChanges(){
            //How long has elapsed?
            var dx = new Date().getTime() - time;
            time = time + dx;

            if(changeTimer > 0) { changeTimer -= dx; }
            //I allow a refresh every 15 seconds even if you are just sitting there 
            //who knows, maybe we missed something once.
            if(changeTimer <= 0) { parseInformation(); changeTimer = 15000; }
            window.requestAnimationFrame(getChanges);
        }; getChanges(); //Run once when you open the program.



        //Returns {}
        function parseInformation() {
            //First check to see if there are any errors or messages.
            var annotations = editor.getSession().getAnnotations();
            //Don't compile if there are errors, there wouldn't be any point.
            for(var i = 0; i < annotations.length; i++){
                if(annotations[i].type == "error") { return; }
            }
            
            var tree = acorn.parse(scope.session.getValue());
            var toCheck = {type:"ForStatement"};
            bfs(tree, toCheck, function(found) { console.log(found); });
            //console.log(tree);
        };

        //
        function bfs(code_tree, object, callback) {
            var toCheck = []; toCheck.push(code_tree);
            var found = false;
            //while(toCheck.length > 0){

            //Leveraging requestAnimationFrame should prevent slowdown on long searches.
            (function runCheck() {
                if (objEquals(toCheck[0], object)) { found = true; } //Did we find a match.
                //Check subtrees.
                if(toCheck[0].body instanceof Array) {
                    for(var obj in toCheck[0].body) {
                        toCheck.push(toCheck[0].body[obj]);
                    }
                } else {
                    toCheck.push(toCheck[0].body);
                }
                //And remove.
                toCheck.shift(); //O(n) - not the most efficient in the world, but it's probably fine.

                //Re-run.
                if(toCheck.length > 0 && found === false) { 
                    window.requestAnimationFrame(runCheck); 
                } else { callback(found); }
            })();
        };

        function bfsSplit(toCheck, object) {

            //window.requestAnimationFrame()
        }

        //Checks to see if an object fulfills all the requirements of a test object.
        function objEquals(obj, testObj) {
            for(var p in testObj){
                if(obj[p] !== testObj[p]) {
                    return false;
                }
            }
            return true;
        };

        return scope;
    }

    window.editor = _init();



    /*var script = acorn.parse(editor.getValue());
    console.log(script);
    printProgramTree(script.body);

    function printProgramTree(body){
        //Set timeout.
        if(body && !body.length){
            body = [body];
        }
        for(var i = 0; i < body.length; i++) {
            var line = body[i];
            console.log("found line: " + line.type);
            if(line.body){
                printProgramTree(line.body);
            }
        }
    }*/
</script>
</body>
</html>