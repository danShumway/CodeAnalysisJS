<!--Just sample code from http://ace.c9.io/#nav=embedding-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>ACE in Action</title>

<style type="text/css" media="screen">

    body, html {
        width:100%;
        height:100%;
        margin:0px;
        padding:0px;
    }

    #feedback {
        color:rgb(200, 200, 200);
        font-family:roboto, "Open Sans", "Helvetica Neue", sans-serif;
        font-size:130%;
        background-color:rgb(50, 50, 50);
        width:100%;
        height:25%;
        padding:20px;
        padding-left:50px;
    }

    .container {
        position:relative;
        display:block;
        width:100%;
        height:75%;
        background-color:black;
        overflow:hidden;
    }

    #editor { 
        /*position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;*/
        position:relative;
        width:100%;
        height:100%;
    }
</style>
</head>
<body>

<div class="container">
    <div id="editor">

    function foo(items) {
        var b;
        for(var i = 0; i &lt; 10; i++) { //Comment the for loop for an error.
            //if(true) {
                b++;
            //} //Uncomment these lines for an error.
        }
        //if(true) { 
            return x; //Comment this line for an error.
        //} //Uncomment these lines for an error.

    }
    </div>
</div>

<div id="feedback">
    Hello
</div>
    
<script src="scripts/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="scripts/acorn/acorn.js" type="text/javascript" charset="utf-8"></script>

<script>

    var annalyze = false;

    function _init() {


        var scope = {};

        //-------------------SETUP AND VARIABLES-------------------------------------------------

        //Included code for setting up the editor.
        //Ace editor is cool.
        var editor = ace.edit("editor");
        editor.setTheme("ace/theme/monokai");
        editor.getSession().setMode("ace/mode/javascript");

        //
        scope.session = editor.getSession(); //Maybe unnecessary?
        scope.pause = false;
        
        var whitelist = [{
                type:"BlockStatement",
                whitelist: [{
                    type:"ForStatement", 
                    message:"You must include a for statement",
                    blacklist:[{
                        type:"IfStatement", message:"You must not put an if statement in your for statement"
                    }]
                }, {
                    type:"ReturnStatement", message:"You must return something!"
                }],
                blacklist: [{
                    message: "don't include an if statement around a return statement",
                    type:"IfStatement", 
                    whitelist:[{type:"ReturnStatement"}]
                }]
            }];
        var blacklist = [{
            type:"ForInStatement",
            message:"Do not include a for in statement!"
        }];
        var structure = [];
        var whitelist_found = [];
        var blacklist_found = [];
        var syntaxErrors = false;


        //-----------------GET USER INPUT---------------------------------------------------------

        var changeTimer = 800;
        //Set up hooks for evaluation.
        editor.getSession().getDocument().on('change', function(e) {
            changeTimer = 800; //If you type something, and don't type something else for 800 miliseconds, then we parse the code.  But we really don't want to parse while you're typing.  That's annoying.
        });



        var time = new Date().getTime();
        //Handles periodically checking for changes and sending out a command to parse the program.
        function getChanges(){
            //How long has elapsed?
            var dx = new Date().getTime() - time;
            time = time + dx;

            if(changeTimer > 0) { changeTimer -= dx; }
            //I allow a refresh every 15 seconds even if you are just sitting there 
            //who knows, maybe we missed something once.  Still wouldn't be ideal, but...
            if(changeTimer <= 0) { parseInformation(); changeTimer = /*1*/85000; }
            window.requestAnimationFrame(getChanges);
        }; getChanges(); //Run immediately


        //-------------------------------CODE REVIEW----------------------------------------------

        //Returns {}
        function parseInformation() {
            //First check to see if there are any errors or messages.
            var annotations = editor.getSession().getAnnotations();
            //Don't compile if there are errors, there wouldn't be any point.
            //Just mark that we have errors.
            syntaxErrors = false;
            for(var i = 0; i < annotations.length; i++){
                if(annotations[i].type == "error") { syntaxErrors = true; return; }
            }
            
            var tree = acorn.parse(scope.session.getValue());

            whitelist_found = [];
            blacklist_found = []; //Reset what we've found.
            codeReview(whitelist, tree, whitelist_found, blacklist_found);
            codeReview(blacklist, tree, blacklist_found, blacklist_found);
        };


        //Loops through whitelist and blacklist and populates a given array with the found patterns.
        function codeReview(list, tree, listResults) {
            for(var required in list) {
                (function(required) {
                    bfs(tree, list[required], function(found){
                        if(found.length === 0) {
                            //We didn't find it, but we still might.

                        } else {
                            if(listResults.indexOf(required) === -1) { 
                                listResults.push(required);
                            }

                            list[required].whitelist_found = [];
                            list[required].blacklist_found = []; //Reset whitelist and blacklist.
                            for(var node in found) {
                                //Look down at the children.
                                codeReview(list[required].whitelist || [], found[node], list[required].whitelist_found);
                                codeReview(list[required].blacklist || [], found[node], list[required].blacklist_found);
                            }
                        }
                    });
                })(required);


            }
        }

        //Simple Breadth-First-Search, adapted to take advantage of requestAnimationFrame.
        //Returns an array of all matching nodes
        function bfs(code_tree, object, callback) {
            var toCheck = []; toCheck.push(code_tree);
            var found = [];
            var directions = ["body", "consequent", "alternate" ];
            //while(toCheck.length > 0){

            //Leveraging requestAnimationFrame should prevent slowdown on long searches.
            (function runCheck() {
                if (objEquals(toCheck[0], object)) { found.push(toCheck[0]); } //Did we find a match.
                //Append subtrees.
                for (var x in directions) {
                    var subtree = directions[x];
                    if(toCheck[0][subtree] instanceof Array) {
                        for(var obj in toCheck[0][subtree]) {
                            toCheck.push(toCheck[0][subtree][obj]);
                        }
                    } else if (toCheck[0][subtree]){
                        toCheck.push(toCheck[0][subtree]);
                    }
                }
                //And remove.
                toCheck.shift(); //O(n) - not the most efficient in the world, but it's probably fine.

                //Re-run.
                if(toCheck.length > 0) { 
                    window.requestAnimationFrame(runCheck); 
                } else { callback(found); }
            })();    
        };

        //Checks to see if an object fulfills all the requirements of a test object.
        //Does not count body as a requirement.
        function objEquals(obj, testObj) {
            for(var p in testObj){
                if(p !== "whitelist" && p !== "blacklist" && p !== "whitelist_found" && p !== "blacklist_found" && p !== "message") {
                    if(obj[p] !== testObj[p]) {
                        return false;
                    }
                }
            }
            return true;
        };

        //----------------GETTING RESULTS OF CODE REVIEW----------------------------

        //Returns a {found:boolean, messages:[array of strings]
        function parseReview(whitelist, blacklist, whitelist_found, blacklist_found, errorMessage) {
            var toReturn = false; var i = 0;
            var children; var _messages = [];

            if(!whitelist){ whitelist = []; } if(!blacklist){ blacklist = []; }
            if(!whitelist_found){ whitelist_found = []; } if(!blacklist_found){ blacklist_found = []; }

            var whiteRequirement = true;
            var blackRequirement = true;

            //Check blacklist.
            for(i = 0; i < blacklist.length; i++) {
                //Any blacklist items found?
                if(blacklist_found.indexOf("" + i) !== -1) {
                    //Make sure they're really found.
                    children = parseReview(blacklist[i].whitelist, blacklist[i].blacklist, blacklist[i].whitelist_found, blacklist[i].blacklist_found, blacklist[i].message);
                    if(children.pass){
                        if(blacklist[i].message) { _messages.push(blacklist[i].message); }
                        blackRequirement = false;
                    }
                } 
            }

            //Check whitelist.
            for(i = 0; i < whitelist.length; i++){
                if(whitelist_found.indexOf("" + i) !== -1) {
                    //And make sure it's really found.
                    children = parseReview(whitelist[i].whitelist, whitelist[i].blacklist, whitelist[i].whitelist_found, whitelist[i].blacklist_found, whitelist[i].message);
                    if(whiteRequirement) { whiteRequirement = children.pass; } //IF we have false, we don't want it to accidentally get set to true.
                    if(children.messages) { _messages = _messages.concat(children.messages); }
                } else {
                    if(whitelist[i].message) {  _messages.push(whitelist[i].message); }
                    whiteRequirement = false;
                }

            }

            return {pass:(whiteRequirement && blackRequirement), messages:_messages};
        }

        var x = 30;
        function gotRequirements(){
            x--;
            if(x < 0) {
                x = 30;
                var status = parseReview(whitelist, blacklist, whitelist_found, blacklist_found, undefined);
                var messageReturn = "";
                if(status.pass && syntaxErrors === false){
                    messageReturn = "Everything looks OK!";
                } else {
                    for (var i = 0; i < status.messages.length; i++)
                    messageReturn += "Error: " + status.messages[i] + "<br>";
                    if(syntaxErrors) { messageReturn += "Error: Fix any syntax errors that are marked above!" }
                }

                document.getElementById("feedback").innerHTML = messageReturn;
            }
            window.requestAnimationFrame(gotRequirements);
        } gotRequirements();

        //---------------------RETURN--------------------------------------------------

        return scope;
    }

    window.editor = _init();

</script>
</body>
</html>